---
import type { HTMLAttributes } from "astro/types";
import { tv } from "tailwind-variants";

type Props = HTMLAttributes<"div"> & {
  maxLength?: number;
  value?: string;
  defaultValue?: string;
  disabled?: boolean;
  pattern?: RegExp | string;
};

export const inputOtp = tv({
  base: "starwind-input-otp flex items-center",
});

const { maxLength = 6, value, defaultValue, disabled = false, pattern, class: className, ...rest } =
  Astro.props;

let patternStr = "\\d";
if (pattern) {
  const stripAnchorsRegex = /^\^|\$$/g;
  if (pattern instanceof RegExp) {
    patternStr = pattern.source.replace(stripAnchorsRegex, "");
  } else {
    patternStr = pattern.replace(stripAnchorsRegex, "");
  }
}
---

<div
  role="group"
  class={inputOtp({ class: className })}
  data-max-length={maxLength}
  data-value={value || defaultValue || ""}
  data-disabled={disabled}
  data-pattern={patternStr}
  data-slot="input-otp"
  {...rest}
>
  <slot />
</div>

<script>
  import type { InputOtpChangeEvent } from "./InputOtpTypes";

  class InputOtpHandler {
    private container: HTMLElement;
    private inputs: HTMLInputElement[];
    private maxLength: number;
    private containerId: string;
    private pattern: RegExp;
    private observer: MutationObserver | null = null;

    constructor(container: HTMLElement, idx: number) {
      this.container = container;
      this.containerId = container.id || `starwind-input-otp-${idx}`;
      if (!container.id) {
        container.id = this.containerId;
      }
      this.maxLength = parseInt(container.dataset.maxLength || "6", 10);
      const patternStr = container.dataset.pattern || "\\d";
      this.pattern = new RegExp(`^${patternStr}$`);
      this.inputs = Array.from(
        container.querySelectorAll<HTMLInputElement>("input[data-otp-slot]"),
      );
      this.init();
    }

    private init() {
      if (this.inputs.length === 0) return;

      const isDisabled = this.container.dataset.disabled === "true";
      if (isDisabled) {
        this.inputs.forEach((input) => {
          input.disabled = true;
        });
        return;
      }

      const initialValue = this.container.dataset.value || "";
      if (initialValue) {
        this.setValue(initialValue);
      }

      this.setupEventListeners();
      this.setupValueSync();
    }

    private setupValueSync() {
      this.observer = new MutationObserver(() => {
        const containerValue = this.container.dataset.value || "";
        const currentValue = this.getValue();
        if (containerValue !== currentValue) {
          this.setValue(containerValue);
        }
      });

      this.observer.observe(this.container, {
        attributes: true,
        attributeFilter: ["data-value"],
      });
    }

    private setupEventListeners() {
      this.inputs.forEach((input, index) => {
        input.addEventListener("input", (e) => this.handleInput(e, index));
        input.addEventListener("keydown", (e) => this.handleKeyDown(e, index));
        input.addEventListener("paste", (e) => this.handlePaste(e, index));
        input.addEventListener("focus", () => this.handleFocus(index));
      });
    }

    private handleInput(e: Event, index: number) {
      const input = e.target as HTMLInputElement;
      const value = input.value.slice(-1);

      if (!this.pattern.test(value)) {
        input.value = "";
        return;
      }

      input.value = value;

      if (value && index < this.inputs.length - 1) {
        this.inputs[index + 1]?.focus();
      }

      this.updateValue();
    }

    private handleKeyDown(e: KeyboardEvent, index: number) {
      const input = e.target as HTMLInputElement;

      if (e.key === "Backspace" && !input.value && index > 0) {
        this.inputs[index - 1]?.focus();
      }

      if (e.key === "ArrowLeft" && index > 0) {
        e.preventDefault();
        this.inputs[index - 1]?.focus();
      }

      if (e.key === "ArrowRight" && index < this.inputs.length - 1) {
        e.preventDefault();
        this.inputs[index + 1]?.focus();
      }

      if (e.key === "Delete" && input.value) {
        input.value = "";
        this.updateValue();
      }
    }

    private handlePaste(e: ClipboardEvent, index: number) {
      e.preventDefault();
      const pastedData = e.clipboardData?.getData("text") || "";
      const matchedChars = this.filterByPattern(pastedData).slice(0, this.maxLength);

      if (matchedChars.length === 0) return;

      for (let i = 0; i < matchedChars.length && index + i < this.inputs.length; i++) {
        this.inputs[index + i].value = matchedChars[i];
      }

      const nextIndex = Math.min(index + matchedChars.length, this.inputs.length - 1);
      this.inputs[nextIndex]?.focus();
      this.updateValue();
    }

    private handleFocus(index: number) {
      const input = this.inputs[index];
      if (input) {
        input.select();
      }
    }

    private filterByPattern(value: string): string[] {
      return value.split("").filter((char) => this.pattern.test(char));
    }

    private setValue(value: string) {
      const matchedChars = this.filterByPattern(value).slice(0, this.maxLength);
      for (let i = 0; i < this.inputs.length; i++) {
        this.inputs[i].value = matchedChars[i] || "";
      }
    }

    private updateValue() {
      const value = this.inputs.map((input) => input.value).join("");
      this.container.dataset.value = value;
      this.dispatchChangeEvent(value);
    }

    public getValue(): string {
      return this.inputs.map((input) => input.value).join("");
    }

    private dispatchChangeEvent(value: string) {
      const event = new CustomEvent<InputOtpChangeEvent["detail"]>("starwind-input-otp:change", {
        bubbles: true,
        detail: {
          value,
          inputOtpId: this.containerId,
        },
      });
      this.container.dispatchEvent(event);
    }
  }

  const inputOtpInstances = new WeakMap<HTMLElement, InputOtpHandler>();
  let inputOtpCounter = 0;

  const setupInputOtps = () => {
    document.querySelectorAll<HTMLElement>(".starwind-input-otp").forEach((container) => {
      if (!inputOtpInstances.has(container)) {
        inputOtpInstances.set(container, new InputOtpHandler(container, inputOtpCounter++));
      }
    });
  };

  setupInputOtps();
  document.addEventListener("astro:after-swap", setupInputOtps);
  document.addEventListener("starwind:init", setupInputOtps);
</script>

